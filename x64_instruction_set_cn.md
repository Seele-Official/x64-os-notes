
- [常见数据声明指令](#常见数据声明指令)
  - [详细解释](#详细解释)
- [数据传输指令](#数据传输指令)
  - [详细解释](#详细解释-1)
- [算术指令](#算术指令)
  - [详细解释](#详细解释-2)
- [位操作指令](#位操作指令)
  - [详细解释](#详细解释-3)
- [控制转移指令](#控制转移指令)
  - [详细解释](#详细解释-4)
- [栈操作指令](#栈操作指令)
  - [详细解释](#详细解释-5)
- [系统指令](#系统指令)
  - [详细解释](#详细解释-6)
- [输入/输出指令](#输入输出指令)
  - [详细解释](#详细解释-7)
- [控制寄存器操作](#控制寄存器操作)
  - [详细解释](#详细解释-8)
  - [Additional Notes:](#additional-notes)

---


## 常见数据声明指令

| 指令      | 大小           | 描述                         |
| --------- | -------------- | ---------------------------- |
| `.byte`   | 1 字节 (8 位)  | 声明 1 字节的数据            |
| `.word`   | 2 字节 (16 位) | 声明 2 字节的数据            |
| `.long`   | 4 字节 (32 位) | 声明 4 字节的数据            |
| `.quad`   | 8 字节 (64 位) | 声明 8 字节的数据            |
| `.ascii`  | 可变           | 声明不带终止符的字符串       |
| `.asciz`  | 可变           | 声明带终止符（`\0`）的字符串 |
| `.align`  | N/A            | 对齐到指定字节边界           |
| `.skip`   | N/A            | 分配未初始化的字节           |
| `.float`  | 4 字节         | 声明 32 位浮点数             |
| `.double` | 8 字节         | 声明 64 位浮点数             |

### 详细解释

1. **`.byte`**
   - **用途**：声明一个 8 位（1 字节）数据。
   - **示例**：
     ```asm
     .byte 0xFF   # 声明 1 个字节的值 0xFF
     ```
2. **`.word`**
   - **用途**：声明一个 16 位（2 字节）数据。
   - **示例**：
     ```asm
     .word 0x1234   # 声明 2 个字节的值 0x1234
     ```
3. **`.long`**
   - **用途**：声明一个 32 位（4 字节）数据。
   - **示例**：
     ```asm
     .long 0x12345678   # 声明 4 个字节的值 0x12345678
     ```
4. **`.quad`**
   - **用途**：声明一个 64 位（8 字节）数据。
   - **示例**：
     ```asm
     .quad 0x123456789ABCDEF0   # 声明 8 个字节的值 0x123456789ABCDEF0
     ```
5. **`.ascii`**
   - **用途**：声明一个 ASCII 字符串（不包含终止符 `\0`）。
   - **示例**：
     ```asm
     .ascii "Hello, world!"   # 声明一个不带终止符的字符串
     ```
6. **`.asciz` / `.string`**
   - **用途**：声明一个以 null 结尾的 ASCII 字符串（包含终止符 `\0`）。
   - **示例**：
     ```asm
     .asciz "Hello, world!"   # 声明一个以 '\0' 结尾的字符串
     ```
7. **`.align`**
   - **用途**：用于对齐内存地址，确保数据在特定的对齐边界上。常用于优化内存访问。
   - **示例**：
     ```asm
     .align 8   # 将下一段数据对齐到 8 字节边界
     ```
8. **`.skip` / `.space`**
   - **用途**：分配未初始化的字节空间。
   - **示例**：
     ```asm
     .skip 16   # 跳过 16 个字节，不初始化它们
     ```
9. **`.float`**
   - **用途**：声明一个 32 位的浮点数。
   - **示例**：
     ```asm
     .float 3.14   # 声明一个 32 位的浮点数
     ```
10. **`.double`**
    - **用途**：声明一个 64 位的浮点数。
    - **示例**：
      ```asm
      .double 3.141592653589793   # 声明一个 64 位的浮点数
      ```
## 数据传输指令

| 指令    | 描述                               |
| ------- | ---------------------------------- |
| `mov`   | 将数据从一个位置移动到另一个位置。 |
| `lea`   | 加载有效地址。                     |
| `push`  | 将操作数压入栈。                   |
| `pop`   | 从栈中弹出操作数。                 |
| `movzx` | 零扩展后传送数据。                 |
| `movsx` | 符号扩展后传送数据。               |
| `xchg`  | 交换两个操作数的值。               |
| `cmove` | 如果相等则移动（基于EFLAGS）。     |
| `cmovz` | 如果为零则移动（同上）。           |

### 详细解释

- **`mov`**：这是最基本的数据传输指令，将源操作数的数据传输到目标位置，支持寄存器与内存之间的传输。
- **`lea`**：加载有效地址，通常用于计算内存地址，但并不实际访问该地址。
- **`push`**：将数据压入栈，栈顶指针递减。
- **`pop`**：从栈顶弹出数据，栈顶指针递增。
- **`movzx`**：将源操作数的较小位数扩展为目标操作数的较大位数，且高位用 0 填充。
- **`movsx`**：与 `movzx` 类似，但符号扩展，高位用符号位填充。
- **`xchg`**：交换两个寄存器或一个寄存器和内存的数据。
- **`cmove` / `cmovz`**：条件移动指令，如果条件满足（ZF=1），则执行数据传输。

---

## 算术指令

| 指令   | 描述                               |
| ------ | ---------------------------------- |
| `add`  | 将两个操作数相加。                 |
| `sub`  | 从第一个操作数中减去第二个操作数。 |
| `mul`  | 无符号乘法。                       |
| `imul` | 有符号乘法。                       |
| `div`  | 无符号除法。                       |
| `idiv` | 有符号除法。                       |
| `inc`  | 将操作数加一。                     |
| `dec`  | 将操作数减一。                     |
| `neg`  | 对操作数取反。                     |
| `adc`  | 带进位相加。                       |
| `sbb`  | 带借位减法。                       |

### 详细解释

- **`add`**：对两个操作数进行简单的加法运算，结果存储在第一个操作数中。
- **`sub`**：对两个操作数进行减法，结果存储在第一个操作数中。
- **`mul`**：进行无符号乘法，结果通常存储在较大寄存器中（如 `rax` 的高低位）。
- **`imul`**：类似 `mul`，但处理有符号操作数。
- **`div`**：无符号除法，将 `rax` 的值除以操作数，商存储在 `rax`，余数存储在 `rdx`。
- **`idiv`**：有符号除法，符号扩展处理。
- **`inc` / `dec`**：简单的递增或递减操作，改变操作数的值。
- **`neg`**：对操作数取负值，相当于 `0 - 操作数`。
- **`adc` / `sbb`**：带有进位或借位的加法和减法，通常在多字节或多位数运算中使用。

---

## 位操作指令

| 指令  | 描述               |
| ----- | ------------------ |
| `and` | 按位与。           |
| `or`  | 按位或。           |
| `xor` | 按位异或。         |
| `not` | 按位取反（补码）。 |
| `shl` | 逻辑左移。         |
| `shr` | 逻辑右移。         |
| `sar` | 算术右移。         |
| `rol` | 循环左移。         |
| `ror` | 循环右移。         |

### 详细解释

- **`and` / `or` / `xor`**：这些是基本的按位运算指令，`and` 清除某些位，`or` 设置某些位，`xor` 用于反转某些位。
- **`not`**：对操作数的每个位进行取反。
- **`shl` / `shr`**：用于位移操作，逻辑位移将空出的位填充为 0。
- **`sar`**：算术右移，保留符号位。
- **`rol` / `ror`**：循环移位，超出部分会重新插入到另一端。

---

## 控制转移指令

| 指令   | 描述                            |
| ------ | ------------------------------- |
| `jmp`  | 无条件跳转。                    |
| `je`   | 如果相等则跳转（ZF=1）。        |
| `jne`  | 如果不相等则跳转（ZF=0）。      |
| `jg`   | 如果大于则跳转（SF=OF, ZF=0）。 |
| `jl`   | 如果小于则跳转（SF!=OF）。      |
| `ja`   | 如果高于则跳转（CF=0, ZF=0）。  |
| `call` | 调用过程。                      |
| `ret`  | 从过程返回。                    |
| `loop` | 基于 `ecx` 的循环。             |
| `iret` | 从中断返回。                    |
| `ljmp` | 远跳转指令，改变CS后跳转        |

> ljmp selector, offset
> - selector：段选择子，指定要跳转到的代码段（通常是 GDT 中的一个选择子）。
> - offset：段内偏移，指定要跳转的具体地址。
### 详细解释

- **`jmp`**：无条件跳转到指定地址或标签。
- **`je` / `jne`**：条件跳转指令，基于 `EFLAGS` 的状态决定是否跳转，常用于比较和判断。
- **`call` / `ret`**：调用和返回函数的指令，`call` 将返回地址压入栈，`ret` 弹出并跳转回调用点。
- **`loop`**：根据 `ecx` 寄存器的值循环执行，`ecx` 每次递减直到为零。
- **`iret`**：用于从中断服务程序返回到先前状态，恢复中断前的寄存器和状态。

---

## 栈操作指令

| 指令     | 描述                         |
| -------- | ---------------------------- |
| `push`   | 将数据压入栈。               |
| `pop`    | 从栈中弹出数据。             |
| `pusha`  | 将所有通用寄存器压入栈。     |
| `popa`   | 将所有通用寄存器从栈中弹出。 |
| `pushf`  | 将标志寄存器压入栈。         |
| `popf`   | 从栈中弹出标志寄存器。       |
| `pushal` | 将所有32位寄存器压入栈。     |
| `popal`  | 将所有32位寄存器从栈中弹出。 |

### 详细解释

- **`push` / `pop`**：栈操作，用于临时保存数据和恢复数据，尤其在函数调用和中断处理中非常重要。
- **`pusha` / `popa`**：一次性将所有寄存器压入或弹出栈，通常用于保存和恢复完整的寄存器状态。
- **`pushf` / `popf`**：保存和恢复标志寄存器中的状态信息，确保处理器的控制标志位保持一致。

---

## 系统指令

| 指令     | 描述                     |
| -------- | ------------------------ |
| `lgdt`   | 加载全局描述符表寄存器。 |
| `lidt`   | 加载中断描述符表寄存器。 |
| `ltr`    | 加载任务寄存器。         |
| `lmsw`   | 加载机器状态字。         |
| `invlpg` | 使页表项失效，刷新TLB。  |
| `hlt`    | 停止CPU，直到中断发生。  |
| `cli`    | 清除中断标志，禁止中断。 |
| `sti`    | 设置中断标志，允许中断。 |
| `rdmsr`  | 读取模型特定寄存器。     |
| `wrmsr`  | 写入模型特定寄存器。     |
| `cpuid`  | 获取处理器信息。         |

### 详细解释

- **`lgdt` / `lidt`**：加载全局描述符表（GDT）或中断描述符表（IDT）的基址和限长，通常在系统初始化时使用。
- **`ltr`**：加载任务寄存器，用于任务切换。
- **`invlpg`**：使特定虚拟地址对应的页表项失效，通常在更改页表或内存映射时使用。
- **`hlt`**：停止 CPU 运行，等待外部中断恢复运行。
- **`cli` / `sti`**：用于启用或禁用中断，`cli` 禁用中断，`sti` 恢复中断。
- **`rdmsr` / `wrmsr`**：读取和写入模型特定寄存器，通常用于访问特定的硬件功能。
- **`cpuid`**：获取有关处理器的详细信息，包括支持的指令集和功能。

---

## 输入/输出指令

| 指令    | 描述                   |
| ------- | ---------------------- |
| `in`    | 从端口读取数据。       |
| `out`   | 向端口写入数据。       |
| `insb`  | 从端口读取字节到内存。 |
| `outsb` | 从内存输出字节到端口。 |
| `insw`  | 从端口读取字到内存。   |
| `outsw` | 从内存输出字到端口。   |

### 详细解释

- **`in` / `out`**：用于与 I/O 设备交互，从指定端口读取或写入数据，通常用于低级设备驱动程序中。
- **`insb` / `outsb`**：字节级的输入和输出操作，用于从端口到内存或从内存到端口的数据传输。
- **`insw` / `outsw`**：字（word）级别的输入和输出操作，处理较大块的数据传输。

---

## 控制寄存器操作

| 指令   | 描述                                   |
| ------ | -------------------------------------- |
| `mov`  | 在控制寄存器和普通寄存器之间移动数据。 |
| `lcr0` | 加载控制寄存器 0。                     |
| `scr4` | 存储控制寄存器 4。                     |

### 详细解释

- **`mov`**：将数据在控制寄存器（如 `CR0`, `CR2`, `CR3`, `CR4`）和常规寄存器之间传输，控制寄存器主要用于管理内存分页、保护模式等系统功能。
- **`lcr0` / `scr4`**：特定的控制寄存器操作，`CR0` 和 `CR4` 是操作系统开发中非常重要的寄存器，分别用于启用分页、保护模式以及扩展系统功能。

### Additional Notes:

- AT&T 语法和 Intel 语法的主要区别是源操作数和目标操作数的顺序不同。在 AT&T 语法中，源操作数在前，目标操作数在后。
- 所有寄存器名称以 `%` 开头，如 `%rax`、`%rsp`。
- 常数以 `$` 开头，如 `$1`。
- 内存地址用括号表示，如 `(%rax)` 表示 `%rax` 指向的内存地址。
- 指令后缀用于标识操作数的大小，如 `b`（字节）、`w`（字）、`l`（双字）、`q`（四字）。
  - 例子：`movl` 表示操作双字，`movq` 表示操作四字。
- 一些寄存器操作比如`mov %ds, %ax`很少在64位平坦模式下使用。

